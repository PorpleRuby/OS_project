<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CPU Scheduling — Non-Preemptive + MLQ (Q3 = RR)</title>
<style>
  /* Simple container styling similar to your example */
  :root{
    --bg:#f4f4f4;
    --card:#fff;
    --muted:#666;
    --border:#ddd;
    --accent:#3a86ff;
    --idle:#aaaaaa;
  }
  html,body{height:100%}
  body{
    margin:20px;
    font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
    background:var(--bg);
    color:#222;
  }
  .container{
    max-width:960px;
    margin:0 auto;
    background:var(--card);
    padding:20px;
    border-radius:8px;
    box-shadow:0 6px 20px rgba(0,0,0,0.08);
  }

  h1{margin:0 0 14px;font-size:20px}
  h2{margin:10px 0 12px;font-size:16px}
  .input-group{margin-bottom:16px;padding:12px;border:1px solid var(--border);border-radius:6px;background:#fff}
  label{display:block;margin-bottom:6px;font-size:13px;color:var(--muted)}
  input[type="number"], select, button, input[type="text"]{
    padding:8px 10px;border:1px solid var(--border);border-radius:5px;font-size:14px;
  }

  .process-input-row{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  .process-input-row > * { font-size:13px }
  .process-input-row .p-id{width:44px;text-align:right;color:var(--muted)}
  .process-input-row input[type="number"]{width:76px}
  .process-input-row select{width:140px}

  .alg-row{display:flex;gap:12px;align-items:center;margin-top:8px;flex-wrap:wrap}

  button.primary{
    background:linear-gradient(90deg,var(--accent),#2a6cff);
    color:white;border:none;padding:9px 14px;border-radius:6px;cursor:pointer;
    box-shadow:0 6px 14px rgba(58,134,255,0.18);
  }
  button.secondary{background:#eee;border:none;padding:8px 12px;border-radius:6px;cursor:pointer}

  table{width:100%;border-collapse:collapse;margin-top:12px}
  th,td{border:1px solid var(--border);padding:8px;text-align:center;font-size:13px}
  thead th{background:linear-gradient(90deg,var(--accent),#2a6cff);color:white}

  /* Gantt styles similar to your preferred mock */
  .gantt-chart-container{margin-top:12px}
  .gantt-bar-wrapper{
    display:flex;height:48px;border:1px solid #333;position:relative;overflow:hidden;border-radius:4px;
  }
  .gantt-segment{
    font-size:12px;color:white;line-height:48px;text-align:center;overflow:hidden;white-space:nowrap;
    display:flex;align-items:center;justify-content:center;border-right:1px solid rgba(255,255,255,0.08);
    transition:transform .12s ease;
  }
  .gantt-segment:hover{transform:scale(1.02)}
  .time-label{position:absolute;bottom:-18px;font-size:11px;color:#111}
  .final-time-label{position:absolute;bottom:-18px;right:0;font-size:11px;color:#111}

  .metrics {display:flex;gap:12px;flex-wrap:wrap;margin-top:14px}
  .metric-box{padding:10px;border-radius:6px;background:#fff;border:1px solid var(--border);min-width:150px}
  .metric-box .val{font-weight:700;font-size:18px;color:var(--accent)}

  @media (max-width:720px){
    .process-input-row{flex-direction:column;align-items:flex-start}
    .process-input-row input[type="number"], .process-input-row select{width:100%}
    .alg-row{flex-direction:column;align-items:stretch}
  }

/* ============================
     New Clean Gantt Styles 
     ============================ */
  .gantt-chart-container {
    margin-top: 20px;
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 20px 10px 40px 10px; /* Extra bottom padding for numbers */
    background: #fff;
    position: relative;
  }

  /* The row of bars */
  .gantt-bar-row {
    display: flex;
    height: 50px;
    width: 100%;
    position: relative;
    border-radius: 4px;
    overflow: hidden; /* Rounds the corners of the whole bar */
    border: 1px solid #333;
    z-index: 1;
  }

  .gantt-segment {
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
    font-size: 13px;
    border-right: 1px solid rgba(255,255,255,0.3);
    position: relative;
    transition: all 0.2s;
  }
  
  .gantt-segment:last-child { border-right: none; }
  .gantt-segment:hover { opacity: 0.9; }

  /* The timeline numbers below */
  .gantt-timeline {
    position: relative;
    height: 20px;
    margin-top: 5px;
    width: 100%;
  }

  .time-marker {
    position: absolute;
    top: 0;
    font-size: 12px;
    font-weight: bold;
    color: #333;
    transform: translateX(-50%); /* Centers text on the line */
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  /* Little vertical tick line connecting number to bar */
  .time-marker::before {
    content: '';
    display: block;
    width: 1px;
    height: 6px;
    background: #333;
    margin-bottom: 2px;
  }
</style>
</head>
<body>
<div class="container">
  <h1>CPU Scheduling Calculator (FCFS, SJF, Priority, Deadline, MLQ)</h1>
  <p style="margin:6px 0 12px;color:var(--muted);font-size:13px">
    MLQ mapping: <strong>Q1 = FCFS</strong> | <strong>Q2 = SJF</strong> | <strong>Q3 = Round Robin (configurable quantum)</strong>
  </p>

  <form id="schedulingForm">
    <div class="input-group">
      <h2>Step 1: Setup</h2>
      <label for="numProcesses">Number of processes (2–9)</label>
      <input id="numProcesses" type="number" min="2" max="9" value="3" required />
    </div>

    <div class="input-group" id="processInputsContainer">
      <h2>Step 2: Process Details</h2>
      <div id="processInputs"></div>
      <div style="margin-top:8px;color:var(--muted);font-size:13px">
        Provide Arrival Time (AT), Burst Time (BT), Priority (1-high..10-low), Deadline, and Queue (1/2/3).
      </div>
    </div>

    <div class="input-group">
      <h2>Step 3: Select Algorithm</h2>
      <label for="algorithmSelect">Scheduling algorithm</label>
      <div class="alg-row">
        <select id="algorithmSelect" required>
          <option value="FCFS">FCFS — First Come First Serve</option>
          <option value="SJF">SJF — Shortest Job First</option>
          <option value="Prio">Priority — Non-preemptive Priority</option>
          <option value="Deadline">Deadline — Earliest Deadline First</option>
          <option value="MLQ">MLQ — Multi-Level Queue (Q1:FCFS, Q2:SJF, Q3:RR)</option>
        </select>

        <label style="display:flex;gap:8px;align-items:center">
          <span style="font-size:13px;color:var(--muted)">Q3 Quantum</span>
          <input id="rrQuantum" type="number" min="1" value="2" style="width:72px" />
        </label>

        <button class="primary" type="submit"><strong>Calculate</strong></button>
        <button type="button" id="resetBtn" class="secondary">Reset</button>
      </div>
    </div>
  </form>

  <!-- RESULTS -->
  <div id="resultsArea" style="display:none">
    <h2>Calculation Results</h2>

    <h3>Gantt Chart</h3>
    <div class="gantt-chart-container">
      <div class="gantt-bar-wrapper" id="ganttChart"></div>
    </div>

    <h3>Process Metrics</h3>
    <table id="metricsTable">
      <thead>
        <tr>
          <th>P</th><th>AT</th><th>BT</th><th>WT</th><th>TAT</th><th>CT</th><th>Queue</th>
        </tr>
      </thead>
      <tbody id="metricsTableBody"></tbody>
    </table>

    <div class="metrics">
      <div class="metric-box"><div style="color:var(--muted)">Average Waiting Time</div><div class="val" id="avgWt">0.00</div></div>
      <div class="metric-box"><div style="color:var(--muted)">Average Turnaround Time</div><div class="val" id="avgTat">0.00</div></div>
      <div class="metric-box"><div style="color:var(--muted)">Total Processes</div><div class="val" id="totalProc">0</div></div>
      <div class="metric-box"><div style="color:var(--muted)">Selected Algorithm</div><div class="val" id="selAlg">-</div></div>
    </div>
  </div>

</div>

<script>
/* ============================
   Scheduling Logic (all in-file)
   ============================ */

/* Helper: find next arrival among not completed */
function findNextArrival(remaining) {
  const arr = remaining.filter(p => !p.isCompleted).map(p => p.at).sort((a,b)=>a-b);
  return arr.length ? arr[0] : undefined;
}

/* FCFS (non-preemptive) */
function calculateFCFS(processes) {
  const sorted = [...processes].sort((a,b)=> a.at !== b.at ? a.at - b.at : a.id - b.id);
  let current = 0, results = [], gantt = [];
  sorted.forEach(p => {
    let start = current < p.at ? p.at : current;
    if (current < p.at) { gantt.push({id:'idle', start: current, end: p.at}); }
    const ct = start + p.bt;
    const tat = ct - p.at;
    const wt = tat - p.bt;
    gantt.push({id: p.id, start, end: ct});
    results.push({...p, ct, tat, wt});
    current = ct;
  });
  return {results, gantt};
}

/* SJF (non-preemptive) */
function calculateSJF(processes) {
  const n = processes.length;
  const remaining = processes.map(p => ({...p, isCompleted:false}));
  let current = 0, results = [], gantt = [];
  while(results.length < n) {
    let avail = remaining.filter(p => p.at <= current && !p.isCompleted);
    if (avail.length === 0) {
      const next = findNextArrival(remaining);
      if (next === undefined) break;
      gantt.push({id:'idle', start: current, end: next});
      current = next;
      continue;
    }
    avail.sort((a,b)=> a.bt !== b.bt ? a.bt - b.bt : a.at - b.at || a.id - b.id);
    const sel = avail[0];
    const idx = remaining.findIndex(p=>p.id===sel.id);
    const start = current;
    const ct = start + sel.bt;
    const tat = ct - sel.at;
    const wt = tat - sel.bt;
    remaining[idx].isCompleted = true;
    gantt.push({id: sel.id, start, end: ct});
    results.push({...sel, ct, tat, wt});
    current = ct;
  }
  return {results, gantt};
}

/* Non-preemptive Priority (lower prio value = higher priority) */
function calculateNonPreemptivePriority(processes) {
  const n = processes.length;
  const remaining = processes.map(p => ({...p, isCompleted:false}));
  let current = 0, results = [], gantt = [];
  while(results.length < n) {
    let avail = remaining.filter(p => p.at <= current && !p.isCompleted);
    if (avail.length === 0) {
      const next = findNextArrival(remaining);
      if (next === undefined) break;
      gantt.push({id:'idle', start: current, end: next});
      current = next;
      continue;
    }
    avail.sort((a,b)=> a.prio !== b.prio ? a.prio - b.prio : a.at - b.at || a.id - b.id);
    const sel = avail[0];
    const idx = remaining.findIndex(p=>p.id===sel.id);
    const start = current;
    const ct = start + sel.bt;
    const tat = ct - sel.at;
    const wt = tat - sel.bt;
    remaining[idx].isCompleted = true;
    gantt.push({id: sel.id, start, end: ct});
    results.push({...sel, ct, tat, wt});
    current = ct;
  }
  return {results, gantt};
}

/* Deadline scheduling (earliest deadline first, non-preemptive) */
function calculateDeadline(processes) {
  const n = processes.length;
  const remaining = processes.map(p => ({...p, isCompleted:false}));
  let current = 0, results = [], gantt = [];
  while(results.length < n) {
    let avail = remaining.filter(p => p.at <= current && !p.isCompleted);
    if (avail.length === 0) {
      const next = findNextArrival(remaining);
      if (next === undefined) break;
      gantt.push({id:'idle', start: current, end: next});
      current = next;
      continue;
    }
    avail.sort((a,b)=> a.deadline !== b.deadline ? a.deadline - b.deadline : a.at - b.at || a.id - b.id);
    const sel = avail[0];
    const idx = remaining.findIndex(p=>p.id===sel.id);
    const start = current;
    const ct = start + sel.bt;
    const tat = ct - sel.at;
    const wt = tat - sel.bt;
    remaining[idx].isCompleted = true;
    gantt.push({id: sel.id, start, end: ct});
    results.push({...sel, ct, tat, wt});
    current = ct;
  }
  return {results, gantt};
}

/* MLQ: Q1 = FCFS, Q2 = SJF, Q3 = Round Robin (preemptive inside Q3)
   Priority between queues: Q1 > Q2 > Q3 (Q1 highest)
*/
function calculateMLQ(processes, rrQuantum = 2) {
  // We'll operate with a 'ready' list and prefer queues
  // For Q3 RR we will allow preemption inside Q3 only.
  const n = processes.length;
  const remaining = processes.map(p => ({...p, rem: p.bt, isCompleted:false}));
  let current = 0, results = [], gantt = [];
  const q3Queue = []; // for maintaining RR order when processes arrive

  // Helper to get available per queue
  function availableForQueue(q) {
    return remaining.filter(p => p.at <= current && !p.isCompleted && p.queue === q);
  }

  // We'll loop until all completed
  while(results.length < n) {
    // Check higher priority queues first
    let sel = null;

    // Q1 (FCFS)
    let q1 = availableForQueue(1);
    if (q1.length > 0) {
      q1.sort((a,b)=> a.at !== b.at ? a.at - b.at : a.id - b.id);
      sel = {...q1[0], queueRule:'Q1-FCFS'};
      // Non-preemptive run entire burst
      const start = current < sel.at ? sel.at : current;
      if (current < sel.at) { gantt.push({id:'idle', start: current, end: sel.at}); current = sel.at; }
      const ct = start + sel.bt;
      const tat = ct - sel.at;
      const wt = tat - sel.bt;
      // mark completed
      const idx = remaining.findIndex(p => p.id === sel.id);
      remaining[idx].isCompleted = true;
      remaining[idx].rem = 0;
      gantt.push({id: sel.id, start, end: ct});
      results.push({...sel, ct, tat, wt});
      current = ct;
      continue;
    }

    // Q2 (SJF)
    let q2 = availableForQueue(2);
    if (q2.length > 0) {
      q2.sort((a,b)=> a.bt !== b.bt ? a.bt - b.bt : a.at - b.at || a.id - b.id);
      sel = {...q2[0], queueRule:'Q2-SJF'};
      const start = current < sel.at ? sel.at : current;
      if (current < sel.at) { gantt.push({id:'idle', start: current, end: sel.at}); current = sel.at; }
      const ct = start + sel.bt;
      const tat = ct - sel.at;
      const wt = tat - sel.bt;
      const idx = remaining.findIndex(p => p.id === sel.id);
      remaining[idx].isCompleted = true;
      remaining[idx].rem = 0;
      gantt.push({id: sel.id, start, end: ct});
      results.push({...sel, ct, tat, wt});
      current = ct;
      continue;
    }

    // Q3 (Round Robin) - allow preemption here
    let q3Avail = availableForQueue(3).sort((a,b)=> a.at !== b.at ? a.at - b.at : a.id - b.id);
    if (q3Avail.length > 0) {
      // Build/refresh q3Queue: ensure arrived processes are in FIFO order
      q3Avail.forEach(p => {
        if (!q3Queue.some(x=>x.id===p.id) && !p.isCompleted) q3Queue.push({...p});
      });

      // If queue is empty (shouldn't be), skip
      if (q3Queue.length === 0) {
        const next = findNextArrival(remaining);
        if (next === undefined) break;
        gantt.push({id:'idle', start: current, end: next});
        current = next;
        continue;
      }

      // Pop first in q3Queue
      const proc = q3Queue.shift();
      const idx = remaining.findIndex(p=>p.id===proc.id);
      // If process already finished by earlier action, skip
      if (remaining[idx].isCompleted) continue;

      // Start at max(current, at)
      const start = Math.max(current, remaining[idx].at);
      if (current < remaining[idx].at) { gantt.push({id:'idle', start: current, end: remaining[idx].at}); current = remaining[idx].at; }
      // Execute for quantum or remaining time, whichever smaller
      const execTime = Math.min(rrQuantum, remaining[idx].rem);
      const ctSegment = start + execTime;
      gantt.push({id: remaining[idx].id, start, end: ctSegment});
      remaining[idx].rem -= execTime;
      current = ctSegment;

      if (remaining[idx].rem <= 0.000001) {
        // finished
        remaining[idx].isCompleted = true;
        const ct = current;
        const tat = ct - remaining[idx].at;
        const wt = tat - remaining[idx].bt;
        results.push({...remaining[idx], ct, tat, wt});
        // also remove from q3Queue if present duplicates
        for (let i=q3Queue.length-1;i>=0;i--) if (q3Queue[i].id === remaining[idx].id) q3Queue.splice(i,1);
      } else {
        // not finished => push to back of q3Queue, but also include any newly arrived Q1/Q2 processes will be checked by next loop iteration
        // Add back to q3Queue tail
        q3Queue.push({...remaining[idx]});
      }
      continue;
    }

    // If none available in any queue, advance to next arrival
    const nextArr = findNextArrival(remaining);
    if (nextArr !== undefined) {
      gantt.push({id:'idle', start: current, end: nextArr});
      current = nextArr;
    } else {
      break;
    }
  }

  // Sort results by process id for table clarity
  results.sort((a,b)=>a.id - b.id);
  return {results, gantt};
}

/* Algorithm mapping */
const algorithms = {
  'FCFS': calculateFCFS,
  'SJF': calculateSJF,
  'Prio': calculateNonPreemptivePriority,
  'Deadline': calculateDeadline,
  'MLQ': calculateMLQ
};

/* ============================
   DOM Manipulation & Rendering
   ============================ */

window.processData = []; // global store

const initialProcessState = { at:0, bt:1, prio:1, deadline:0, queue:1 };

/* Generate process input rows dynamically */
function generateProcessInputs() {
  const num = Math.max(2, Math.min(9, parseInt(document.getElementById('numProcesses').value || 3)));
  const container = document.getElementById('processInputs');
  container.innerHTML = '';
  window.processData = [];

  for (let i=1;i<=num;i++){
    const p = { id: i, ...initialProcessState };
    // sensible defaults
    p.at = (i-1); p.bt = Math.max(1, Math.floor(Math.random()*6)+1); p.prio = Math.floor(Math.random()*5)+1;
    p.deadline = p.at + p.bt + 3; p.queue = 1;
    window.processData.push(p);

    // build row
    const row = document.createElement('div');
    row.className = 'process-input-row';
    row.innerHTML = `
      <div class="p-id">P${i}:</div>
      <input type="number" data-id="${i}" data-key="at" value="${p.at}" min="0" title="Arrival Time" required />
      <input type="number" data-id="${i}" data-key="bt" value="${p.bt}" min="1" title="Burst Time" required />
      <input type="number" data-id="${i}" data-key="prio" value="${p.prio}" min="1" max="10" title="Priority" />
      <input type="number" data-id="${i}" data-key="deadline" value="${p.deadline}" min="0" title="Deadline"/>
      <select data-id="${i}" data-key="queue" title="Queue">
        <option value="1">Queue 1 (FCFS)</option>
        <option value="2">Queue 2 (SJF)</option>
        <option value="3">Queue 3 (Round Robin)</option>
      </select>
    `;
    // attach handlers
    Array.from(row.querySelectorAll('input,select')).forEach(el=>{
      el.addEventListener('input', ()=> handleInputChange(el));
      el.addEventListener('change', ()=> handleInputChange(el));
    });
    container.appendChild(row);
  }
  updateInputRequiredStatus();
}

/* Handle input changes */
function handleInputChange(el) {
  const id = parseInt(el.getAttribute('data-id'));
  const key = el.getAttribute('data-key');
  let val;
  if (el.tagName === 'SELECT') val = parseInt(el.value);
  else val = parseFloat(el.value);
  const idx = window.processData.findIndex(p=>p.id === id);
  if (idx !== -1) window.processData[idx][key] = Number.isNaN(val) ? 0 : val;
}

/* Disable/enable inputs based on selected algorithm (alg-specific fields required) */
function updateInputRequiredStatus() {
  const alg = document.getElementById('algorithmSelect').value;
  const inputs = document.querySelectorAll('#processInputs input[data-key], #processInputs select[data-key]');
  inputs.forEach(input=>{
    const key = input.getAttribute('data-key');
    let disabled = false, required = false;
    // all need AT and BT
    if (key === 'at' || key === 'bt') { disabled = false; required = true; }
    else if (alg === 'Prio' && key === 'prio') { disabled=false; required=true; }
    else if (alg === 'Deadline' && key === 'deadline') { disabled=false; required=true; }
    else if (alg === 'MLQ' && (key === 'queue' || key === 'prio')) { disabled=false; required = (key==='queue'); }
    else { disabled = true; required = false; }
    input.disabled = disabled;
    input.required = required;
    input.style.opacity = disabled ? '0.6' : '1';
  });
}

/* Render metrics table */
function renderMetrics(results) {
  const tbody = document.getElementById('metricsTableBody');
  tbody.innerHTML = '';
  let totalWt = 0, totalTat = 0;
  results.forEach(p=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>P${p.id}</td><td>${p.at}</td><td>${p.bt}</td><td>${p.wt.toFixed(2)}</td><td>${p.tat.toFixed(2)}</td><td>${p.ct}</td><td>${p.queue}</td>`;
    tbody.appendChild(tr);
    totalWt += p.wt; totalTat += p.tat;
  });
  const num = results.length || 1;
  document.getElementById('avgWt').textContent = (totalWt/num).toFixed(2);
  document.getElementById('avgTat').textContent = (totalTat/num).toFixed(2);
  document.getElementById('totalProc').textContent = results.length;
}

/* Gantt rendering with colored blocks per process */
function renderGanttChart(gantt) {
  const chart = document.getElementById('ganttChart');
  chart.innerHTML = '';
  if (!gantt || gantt.length === 0) return;
  const finalT = gantt[gantt.length-1].end || 1;

  const colors = [
    '#4CAF50','#FFC107','#2196F3','#E91E63','#9C27B0','#FF6B6B','#00B894','#6C5CE7','#F8961E'
  ];

  gantt.forEach((seg, idx) => {
    const dur = seg.end - seg.start;
    const widthPct = (dur / finalT) * 100;
    const div = document.createElement('div');
    div.className = 'gantt-segment';
    div.style.width = widthPct + '%';
    div.style.background = seg.id === 'idle' ? '--' : (seg.id==='idle'? '#aaa' : colors[(seg.id-1) % colors.length]);
    // set background properly (can't use CSS var with fallback right away)
    div.style.backgroundColor = seg.id === 'idle' ? getComputedStyle(document.documentElement).getPropertyValue('--idle') || '#aaa' : colors[(seg.id-1) % colors.length];
    div.textContent = seg.id === 'idle' ? 'Idle' : `P${seg.id}`;
    div.title = seg.id === 'idle' ? `Idle: ${seg.start} - ${seg.end}` : `P${seg.id}: ${seg.start} - ${seg.end}`;
    chart.appendChild(div);

    // start label for first segment
    if (idx === 0) {
      const sLabel = document.createElement('span');
      sLabel.className = 'time-label';
      sLabel.style.left = '0';
      sLabel.textContent = seg.start;
      chart.appendChild(sLabel);
    }

    // end label
    if (seg.end >= 0) {
      const eLabel = document.createElement('span');
      eLabel.className = 'time-label';
      eLabel.textContent = seg.end;
      if (idx === gantt.length-1) {
        eLabel.className = 'final-time-label';
        eLabel.style.right = '0';
      } else {
        eLabel.style.left = ((seg.end / finalT) * 100) + '%';
      }
      chart.appendChild(eLabel);
    }
  });
}

/* Update UI selected algorithm display */
function updateSelectedAlgDisplay() {
  const alg = document.getElementById('algorithmSelect').value;
  document.getElementById('selAlg').textContent = alg;
}

/* Form submit -> compute and render */
document.getElementById('schedulingForm').addEventListener('submit', function(e){
  e.preventDefault();
  const alg = document.getElementById('algorithmSelect').value;
  const num = Math.max(2, Math.min(9, parseInt(document.getElementById('numProcesses').value || 3)));
  const calcFn = algorithms[alg];
  if (!calcFn) { alert('Select algorithm'); return; }

  // slice processes up to num
  const inputProcesses = window.processData.slice(0, num).map(p => ({...p})); // copy

  // validation
  for (const p of inputProcesses) {
    if (!Number.isFinite(p.bt) || p.bt <= 0) { alert(`Invalid BT for P${p.id}`); return; }
    if (!Number.isFinite(p.at) || p.at < 0) { alert(`Invalid AT for P${p.id}`); return; }
    if (alg === 'Prio' && (!Number.isFinite(p.prio))) { alert('Priority required'); return; }
    if (alg === 'Deadline' && (!Number.isFinite(p.deadline))) { alert('Deadline required'); return; }
  }

  let res;
  if (alg === 'MLQ') {
    const q = parseInt(document.getElementById('rrQuantum').value) || 2;
    res = calculateMLQ(inputProcesses, q);
  } else {
    res = calcFn(inputProcesses);
  }

  // If algorithms return results in different order, keep table sorted by id
  const resultsSortedForTable = (res.results || []).slice().sort((a,b)=>a.id - b.id);

  renderMetrics(resultsSortedForTable);
  renderGanttChart(res.gantt || []);
  updateSelectedAlgDisplay();
  document.getElementById('resultsArea').style.display = 'block';
  // scroll
  document.getElementById('resultsArea').scrollIntoView({behavior:'smooth'});
});

/* Reset button */
document.getElementById('resetBtn').addEventListener('click', ()=>{
  document.getElementById('numProcesses').value = 3;
  generateProcessInputs();
  document.getElementById('resultsArea').style.display = 'none';
});

/* Update required status when algorithm changes */
document.getElementById('algorithmSelect').addEventListener('change', ()=>{
  updateInputRequiredStatus();
  updateSelectedAlgDisplay();
});

/* initialize */
window.onload = function(){
  generateProcessInputs();
  updateSelectedAlgDisplay();
  // triggers when user changes number via mouse or keyboard
  document.getElementById('numProcesses').addEventListener('input', generateProcessInputs);
  document.getElementById('numProcesses').addEventListener('change', generateProcessInputs);
};

/* Gantt rendering with aligned start/end numbers */
function renderGanttChart(gantt) {
  const container = document.getElementById('ganttChart');
  // We need to clear the wrapper completely and rebuild structure
  // The HTML provided in the original code had a wrapper. 
  // Let's target the parent .gantt-chart-container to rewrite strictly
  const wrapper = document.querySelector('.gantt-chart-container');
  wrapper.innerHTML = ''; // Clear previous

  if (!gantt || gantt.length === 0) {
    wrapper.innerHTML = '<div style="text-align:center;color:#999;padding:20px;">No Data</div>';
    return;
  }

  const finalT = gantt[gantt.length-1].end;
  const colors = [
    '#4CAF50','#FFC107','#2196F3','#E91E63','#9C27B0','#FF6B6B','#00B894','#6C5CE7','#F8961E'
  ];

  // 1. Create the Bar Row
  const barRow = document.createElement('div');
  barRow.className = 'gantt-bar-row';

  gantt.forEach((seg) => {
    const dur = seg.end - seg.start;
    const widthPct = (dur / finalT) * 100;
    
    const div = document.createElement('div');
    div.className = 'gantt-segment';
    div.style.width = widthPct + '%';
    
    // Style
    const isIdle = seg.id === 'idle';
    div.style.backgroundColor = isIdle ? '#aaaaaa' : colors[(seg.id-1) % colors.length];
    div.textContent = isIdle ? 'Idle' : `P${seg.id}`;
    div.title = `${isIdle?'Idle':'P'+seg.id} (${seg.start} - ${seg.end})`;
    
    barRow.appendChild(div);
  });

  wrapper.appendChild(barRow);

  // 2. Create the Timeline Row (Numbers)
  const timeline = document.createElement('div');
  timeline.className = 'gantt-timeline';

  // Helper to add a marker
  function addMarker(time, isLast = false) {
    const pct = (time / finalT) * 100;
    const marker = document.createElement('div');
    marker.className = 'time-marker';
    marker.style.left = pct + '%';
    marker.innerText = time;
    
    // Fix alignment for edge cases
    if (time === 0) {
      marker.style.transform = 'translateX(0%)'; // Align left edge
      marker.style.alignItems = 'flex-start';
    } else if (isLast) {
      marker.style.transform = 'translateX(-100%)'; // Align right edge
      marker.style.alignItems = 'flex-end';
    }
    
    timeline.appendChild(marker);
  }

  // Add 0 marker
  addMarker(0);

  // Add marker for the end of every segment
  // We use a Set to prevent duplicate numbers if a process ends at 5 and next starts at 5
  let placedTimes = new Set([0]);

  gantt.forEach((seg, idx) => {
    if (!placedTimes.has(seg.end)) {
      const isLast = (idx === gantt.length - 1);
      addMarker(seg.end, isLast);
      placedTimes.add(seg.end);
    }
  });

  wrapper.appendChild(timeline);
}
</script>
</body>
</html>
